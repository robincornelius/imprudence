/**
 * @file llsdserialize_test.cpp
 * @brief LLSDSerialize unit tests
 *
 * $LicenseInfo:firstyear=2006&license=mit$
 *
 * Copyright (c) 2006-2010, Linden Research, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * $/LicenseInfo$
 */


#include "lltut.h"

#include <sstream>
#include <string.h> // for memcpy

#include "llsd.h"
#include "llsdserialize.h"

#ifndef LL_WINDOWS
#include <netinet/in.h>
#endif
#ifdef LL_WINDOWS
#include <Winsock2.h>
typedef U32 uint32_t;
#endif


std::vector<U8> string_to_vector(std::string str)
{
	// bc LLSD can't...
	size_t len = (size_t)str.length();
	std::vector<U8> v(len);
	for (size_t i = 0; i < len ; i++)
	{
		v[i] = str[i];
	}
	return v;
}

namespace tut
{
	struct sd_xml_data
	{
		LLSD mSD;
		void xml_test(const char* name, const std::string& expected)
		{
			std::ostringstream ostr;
			ostr << LLSDToXML(mSD);
			ensure_equals(name, ostr.str(), expected);
		}
	};

	typedef test_group<sd_xml_data> sd_xml_test;
	typedef sd_xml_test::object sd_xml_object;
	tut::sd_xml_test sd_xml_stream("sd_xml_serialization");

	template<> template<>
	void sd_xml_object::test<1>()
	{
		// random atomic tests
		std::string expected;

		expected = "<llsd><undef /></llsd>\n";
		xml_test("undef", expected);

		mSD = 3463;
		expected = "<llsd><integer>3463</integer></llsd>\n";
		xml_test("integer", expected);

		mSD = "";
		expected = "<llsd><string /></llsd>\n";
		xml_test("empty string", expected);

		mSD = "foobar";
		expected = "<llsd><string>foobar</string></llsd>\n";
		xml_test("string", expected);

		mSD = LLSD::UUID::null;
		expected = "<llsd><uuid /></llsd>\n";
		xml_test("null uuid", expected);

		mSD = LLSD::UUID("c96f9b1e-f589-4100-9774-d98643ce0bed");
		expected = "<llsd><uuid>c96f9b1e-f589-4100-9774-d98643ce0bed</uuid></llsd>\n";
		xml_test("uuid", expected);

		mSD = LLSD::URI("https://secondlife.com/login");
		expected = "<llsd><uri>https://secondlife.com/login</uri></llsd>\n";
		xml_test("uri", expected);

		mSD = LLSD::Date("2006-04-24T16:11:33Z");
		expected = "<llsd><date>2006-04-24T16:11:33Z</date></llsd>\n";
		xml_test("date", expected);

		// Generated by: echo -n 'hello' | openssl enc -e -base64
		std::vector<U8> hello;
		hello.push_back('h');
		hello.push_back('e');
		hello.push_back('l');
		hello.push_back('l');
		hello.push_back('o');
		mSD = hello;
		expected = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
		xml_test("binary", expected);
	}

	template<> template<>
	void sd_xml_object::test<2>()
	{
		// tests with boolean values.
		std::string expected;

		mSD = true;
		expected = "<llsd><boolean>true</boolean></llsd>\n";
		xml_test("bool alpha true", expected);
		mSD = false;
		expected = "<llsd><boolean>false</boolean></llsd>\n";
		xml_test("bool alpha false", expected);
	}


	template<> template<>
	void sd_xml_object::test<3>()
	{
		// tests with real values.
		std::string expected;

		mSD = 1.0;
		expected = "<llsd><real>1</real></llsd>\n";
		xml_test("real 1", expected);

		mSD = -34379.015625;
		expected = "<llsd><real>-34379.015625</real></llsd>\n";
		xml_test("higher precision", expected);

		mSD = 0.0;
		expected = "<llsd><real>0</real></llsd>\n";
		xml_test("no decimal 0", expected);
	}

	template<> template<>
	void sd_xml_object::test<4>()
	{
		// tests with arrays
		std::string expected;

		mSD = LLSD::emptyArray();
		expected = "<llsd><array /></llsd>\n";
		xml_test("empty array", expected);

		mSD.append(LLSD());
		expected = "<llsd><array><undef /></array></llsd>\n";
		xml_test("1 element array", expected);

		mSD.append(1);
		expected = "<llsd><array><undef /><integer>1</integer></array></llsd>\n";
		xml_test("2 element array", expected);
	}

	template<> template<>
	void sd_xml_object::test<5>()
	{
		// tests with arrays
		std::string expected;

		mSD = LLSD::emptyMap();
		expected = "<llsd><map /></llsd>\n";
		xml_test("empty map", expected);

		mSD["foo"] = "bar";
		expected = "<llsd><map><key>foo</key><string>bar</string></map></llsd>\n";
		xml_test("1 element map", expected);

		mSD["baz"] = LLSD();
		expected = "<llsd><map><key>baz</key><undef /><key>foo</key><string>bar</string></map></llsd>\n";
		xml_test("2 element map", expected);
	}

	template<> template<>
	void sd_xml_object::test<6>()
	{
		// tests with binary
		std::string expected;

		// Generated by: echo -n 'hello' | openssl enc -e -base64
		mSD = string_to_vector("hello");
		expected = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
		xml_test("binary", expected);

		mSD = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
		expected = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBlNDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZmZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMyOXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
		xml_test("binary", expected);
	}

	template<class Traits>
	class TestLLSDSerializeData
	{
	public:
		void doRoundTripTests();
		void checkRoundTrip(const std::string&, const LLSD& v);
	};

	template<class Traits>
	void TestLLSDSerializeData<Traits>::checkRoundTrip(const std::string& msg, const LLSD& v)
	{
		std::stringstream stream;
		Traits::format(v, stream);
		LLSD w;
		Traits::parse(w, stream, stream.str().size(), NULL);
		ensure_equals(msg.c_str(), w, v);
	}

	// Specialization since JSON serialization maps several
	// LLSD types to JSON strings and there is a single number type
	template<>
	void TestLLSDSerializeData<LLSDJSONTraits>::checkRoundTrip(const std::string& msg, const LLSD& v)
	{
		std::stringstream stream;
		LLSDJSONTraits::format(v, stream);
		LLSD w;
		LLSDJSONTraits::parse(w, stream, stream.str().size(), NULL);

		switch (v.type())
		{
		case LLSD::TypeURI:
		case LLSD::TypeUUID:
		case LLSD::TypeDate:
		case LLSD::TypeBinary:
			ensure_equals(msg.c_str(), w, LLSD(v.asString()));
			return;

		case LLSD::TypeInteger:
		case LLSD::TypeReal:
			ensure_equals(msg.c_str(), w.asReal(), v.asReal());
			return;

		default:
			ensure_equals(msg.c_str(), w, v);
			return;
		}

	}

	static void fillmap(LLSD& root, U32 width, U32 depth)
	{
		if(depth == 0)
		{
			root["foo"] = "bar";
			return;
		}

		for(U32 i = 0; i < width; ++i)
		{
			std::ostringstream key;
			key << "child " << i;
			root[key.str()] = LLSD::emptyMap();
			fillmap(root[key.str()], width, depth - 1);
		}
	}

	template<class Traits>
	void TestLLSDSerializeData<Traits>::doRoundTripTests()
	{
		LLSD v;
		checkRoundTrip("undefined", v);

		v = true;
		checkRoundTrip("true bool", v);

		v = false;
		checkRoundTrip("false bool", v);

		v = 1;
		checkRoundTrip("positive int", v);

		v = 0;
		checkRoundTrip("zero int", v);

		v = -1;
		checkRoundTrip("negative int", v);

		v = 1234.5f;
		checkRoundTrip("positive float", v);

		v = 0.0f;
		checkRoundTrip("zero float", v);

		v = -1234.5f;
		checkRoundTrip(" negative float", v);

		// FIXME: need a NaN test

		v = LLSD::UUID::null;
		checkRoundTrip("null uuid", v);

		LLSD::UUID newUUID("75d0e82e-6ee3-4484-ac2a-a718e4acc57b");
		v = newUUID;
		checkRoundTrip("new uuid", v);

		v = "";
		checkRoundTrip("empty string", v);

		v = "some string";
		checkRoundTrip("non-empty string", v);

		v =
"Second Life is a 3-D virtual world entirely built and owned by its residents. "
"Since opening to the public in 2003, it has grown explosively and today is "
"inhabited by nearly 100,000 people from around the globe.\n"
"\n"
"From the moment you enter the World you'll discover a vast digital continent, "
"teeming with people, entertainment, experiences and opportunity. Once you've "
"explored a bit, perhaps you'll find a perfect parcel of land to build your "
"house or business.\n"
"\n"
"You'll also be surrounded by the Creations of your fellow residents. Because "
"residents retain the rights to their digital creations, they can buy, sell "
"and trade with other residents.\n"
"\n"
"The Marketplace currently supports millions of US dollars in monthly "
"transactions. This commerce is handled with the in-world currency, the Linden "
"dollar, which can be converted to US dollars at several thriving online "
"currency exchanges.\n"
"\n"
"Welcome to Second Life. We look forward to seeing you in-world!\n"
		;
		checkRoundTrip("long string", v);

		v = "<tag>";	// needs escaping both at the front and the back
		checkRoundTrip("string with xml tag", v);

		v = "B&O - O'Keefe - \"OMG!\""; //
		checkRoundTrip("string with xml specials", v);

		static const U32 block_size = 0x000020;
		for (U32 block = 0x000000; block <= 0x10ffff; block += block_size)
		{
			std::ostringstream out;

			for (U32 c = block; c < block + block_size; ++c)
			{
				if (c <= 0x000001f
					&& c != 0x000009
					&& c != 0x00000a)
				{
					// see XML standard, sections 2.2 and 4.1
					continue;
				}
				if (0x00d800 <= c  &&  c <= 0x00dfff) { continue; }
				if (0x00fdd0 <= c  &&  c <= 0x00fdef) { continue; }
				if ((c & 0x00fffe) == 0x00fffe) { continue; }
					// see Unicode standard, section 15.8

				if (c <= 0x00007f)
				{
					out << (char)(c & 0x7f);
				}
				else if (c <= 0x0007ff)
				{
					out << (char)(0xc0 | ((c >> 6) & 0x1f));
					out << (char)(0x80 | ((c >> 0) & 0x3f));
				}
				else if (c <= 0x00ffff)
				{
					out << (char)(0xe0 | ((c >> 12) & 0x0f));
					out << (char)(0x80 | ((c >>  6) & 0x3f));
					out << (char)(0x80 | ((c >>  0) & 0x3f));
				}
				else
				{
					out << (char)(0xf0 | ((c >> 18) & 0x07));
					out << (char)(0x80 | ((c >> 12) & 0x3f));
					out << (char)(0x80 | ((c >>  6) & 0x3f));
					out << (char)(0x80 | ((c >>  0) & 0x3f));
				}
			}

			v = out.str();

			std::ostringstream blockmsg;
			blockmsg << "unicode string block 0x" << std::hex << block;
			checkRoundTrip(blockmsg.str(), v);
		}

		LLSD::Date epoch;
		v = epoch;
		checkRoundTrip("epoch date", v);

		LLSD::Date aDay("2002-12-07T05:07:15.00Z");
		v = aDay;
		checkRoundTrip("date", v);

		LLSD::URI path("http://slurl.com/secondlife/Ambleside/57/104/26/");
		v = path;
		checkRoundTrip("url", v);

		const char source[] = "it must be a blue moon again";
		std::vector<U8> data;
		copy(&source[0], &source[sizeof(source)], back_inserter(data));

		v = data;
		checkRoundTrip("binary", v);

		v = LLSD::emptyMap();
		checkRoundTrip("empty map", v);

		v = LLSD::emptyMap();
		v["name"] = "luke";		//v.insert("name", "luke");
		v["age"] = 3;			//v.insert("age", 3);
		checkRoundTrip("map", v);

		v.clear();
		v["a"]["1"] = true;
		v["b"]["0"] = false;
		checkRoundTrip("nested maps", v);

		v = LLSD::emptyArray();
		checkRoundTrip("empty array", v);

		v = LLSD::emptyArray();
		v.append("ali");
		v.append(28);
		checkRoundTrip("array", v);

		v.clear();
		v[0][0] = true;
		v[1][0] = false;
		checkRoundTrip("nested arrays", v);

		v = LLSD::emptyMap();
		fillmap(v, 10, 4); // 10^4 maps
		checkRoundTrip("many nested maps", v);
	}

	template <class Traits>
	class TestLLSDSerialize
	{
	public:
		typedef tut::test_group< TestLLSDSerializeData<Traits> > Group;
//		typedef Group::object Object;
	};

	TestLLSDSerialize<LLSDXMLTraits>::Group
		gTestLLSDXMLSerializeGroup("LLSD XML serialization");

	template<> template<>
	void TestLLSDSerialize<LLSDXMLTraits>::Group::object::test<1>()
	{
		doRoundTripTests();
	}

	TestLLSDSerialize<LLSDBinaryTraits>::Group
		gTestLLSDBinarySerializeGroup("LLSD Binary serialization");

	template<> template<>
	void TestLLSDSerialize<LLSDBinaryTraits>::Group::object::test<1>()
	{
		doRoundTripTests();
	}

	TestLLSDSerialize<LLSDJSONTraits>::Group
		gTestLLSDJSONSerializeGroup("LLSD JSON serialization");

	template<> template<>
	void TestLLSDSerialize<LLSDJSONTraits>::Group::object::test<1>()
	{
		doRoundTripTests();
	}

#ifdef LL_LEGACY
	TestLLSDSerialize<LLSDNotationTraits>::Group
		gTestLLSDNotationSerializeGroup("LLSD Notation serialization");

	template<> template<>
	void TestLLSDSerialize<LLSDNotationTraits>::Group::object::test<1>()
	{
		doRoundTripTests();
	}
#endif


	/**
	 * @class TestLLSDParsing
	 * @brief Base class for of a parse tester.
	 */
	template <class Traits>
	class TestLLSDParsing
	{
	public:
		void ensureParse(
			const std::string& msg,
			const std::string& in,
			const LLSD& expected_value)
		{
			std::stringstream input;
			input.str(in);

			LLSD parsed_value;
			bool parse_result = Traits::parse(parsed_value, input, in.size(), NULL);
			ensure(msg + " parsed", parse_result);
			ensure_equals(msg + " value", parsed_value, expected_value);
		}

		void ensureParseFailure(
						 const std::string& msg,
						 const std::string& in,
						 const std::string& fragment = "")
		{
			std::stringstream input;
			input.str(in);

			LLSD parsed_value;
			std::string error_msg;
			bool parse_result = Traits::parse(parsed_value, input, in.size(), &error_msg);
			ensure_not(msg + " parsed", parse_result);
			if (fragment != "")
			{
				ensure_contains(msg + " message", error_msg, fragment);
			}
		}
	};


	/**
	 * @class TestLLSDXMLParsing
	 * @brief Concrete instance of a parse tester.
	 */
	class TestLLSDXMLParsing : public TestLLSDParsing<LLSDXMLTraits>
	{
	public:
		TestLLSDXMLParsing() {}
	};

	typedef tut::test_group<TestLLSDXMLParsing> TestLLSDXMLParsingGroup;
	typedef TestLLSDXMLParsingGroup::object TestLLSDXMLParsingObject;
	TestLLSDXMLParsingGroup gTestLLSDXMLParsingGroup("llsd XML parsing");

	template<> template<>
	void TestLLSDXMLParsingObject::test<1>()
	{
		// test handling of xml not recognized as llsd results in an
		// LLSD Undefined
		ensureParseFailure(
			"malformed xml",
			"<llsd><string>ha ha</string>",
		    "XML parse");
		ensureParseFailure(
			"not llsd",
			"<html><body><p>ha ha</p></body></html>",
			"llsd");
		ensureParseFailure(
			"value without llsd",
			"<string>ha ha</string>",
		    "llsd");
		ensureParseFailure(
			"key without llsd",
			"<key>ha ha</key>",
			"llsd");
		ensureParseFailure(
		    "invalid elements",
		    "<llsd><text>ha ha</text></llsd>",
		    "invalid");
	}


	template<> template<>
	void TestLLSDXMLParsingObject::test<2>()
	{
		// test handling of unrecognized or unparseable llsd values
		ensureParseFailure(
			"unknown data type",
			"<llsd><map>"
				"<key>amy</key><integer>23</integer>"
				"<key>bob</key><bigint>99999999999999999</bigint>"
				"<key>cam</key><real>1.23</real>"
			"</map></llsd>",
			"bigint");
	}

	template<> template<>
	void TestLLSDXMLParsingObject::test<3>()
	{
		// test handling of nested bad data
		ensureParseFailure(
			"map with html",
			"<llsd><map>"
				"<key>amy</key><integer>23</integer>"
				"<html><body>ha ha</body></html>"
				"<key>cam</key><real>1.23</real>"
			"</map></llsd>",
			"key");

		ensureParseFailure(
			"map with value for key",
			"<llsd><map>"
				"<key>amy</key><integer>23</integer>"
				"<string>ha ha</string>"
				"<key>cam</key><real>1.23</real>"
			"</map></llsd>",
			"key");

		ensureParseFailure(
			"map with map of html",
			"<llsd><map>"
				"<key>amy</key><integer>23</integer>"
				"<key>bob</key>"
				"<map>"
					"<html><body>ha ha</body></html>"
				"</map>"
				"<key>cam</key><real>1.23</real>"
			"</map></llsd>",
			"key");

		ensureParseFailure(
			"array value of html",
			"<llsd><array>"
				"<integer>23</integer>"
				"<html><body>ha ha</body></html>"
				"<real>1.23</real>"
			"</array></llsd>",
			"html");

		ensureParseFailure(
			"array with map of html",
			"<llsd><array>"
				"<integer>23</integer>"
				"<map>"
					"<html><body>ha ha</body></html>"
				"</map>"
				"<real>1.23</real>"
			"</array></llsd>",
			"key");
	}

	template<> template<>
	void TestLLSDXMLParsingObject::test<4>()
	{
		// test handling of binary object in XML
		std::string xml;
		LLSD expected;

		// Generated by: echo -n 'hello' | openssl enc -e -base64
		expected = string_to_vector("hello");
		xml = "<llsd><binary encoding=\"base64\">aGVsbG8=</binary></llsd>\n";
		ensureParse(
			"the word 'hello' packed in binary encoded base64",
			xml,
			expected);

		expected = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
		xml = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBlNDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZmZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMyOXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
		ensureParse(
			"a common binary blob for object -> agent offline inv transfer",
			xml,
			expected);

		expected = string_to_vector("6|6|asdfhappybox|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|60e44ec5-305c-43c2-9a19-b4b89b1ae2a6|00000000-0000-0000-0000-000000000000|7fffffff|7fffffff|0|0|82000|450fe394-2904-c9ad-214c-a07eb7feec29|(No Description)|0|10|0");
		xml = "<llsd><binary encoding=\"base64\">Nnw2fGFzZGZoYXBweWJveHw2MGU0NGVjNS0zMDVjLTQzYzItOWExOS1iNGI4OWIxYWUyYTZ8NjBl\n";
		xml += "NDRlYzUtMzA1Yy00M2MyLTlhMTktYjRiODliMWFlMmE2fDYwZTQ0ZWM1LTMwNWMtNDNjMi05YTE5\n";
		xml += "LWI0Yjg5YjFhZTJhNnwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8N2ZmZmZm\n";
		xml += "ZmZ8N2ZmZmZmZmZ8MHwwfDgyMDAwfDQ1MGZlMzk0LTI5MDQtYzlhZC0yMTRjLWEwN2ViN2ZlZWMy\n";
		xml += "OXwoTm8gRGVzY3JpcHRpb24pfDB8MTB8MA==</binary></llsd>\n";
		ensureParse(
			"a common binary blob for object -> agent offline inv transfer",
			xml,
			expected);
	}
	/*
	TODO:
		test XML parsing
			binary with unrecognized encoding
			nested LLSD tags
			multiple values inside an LLSD
	*/

#ifdef LL_LEGACY
	class TestLLSDLegacyXMLParsing : public TestLLSDParsing<LLSDLegacyXMLTraits>
	{
	public:
		TestLLSDLegacyXMLParsing() {}
	};

	typedef tut::test_group<TestLLSDLegacyXMLParsing> TestLLSDLegacyXMLParsingGroup;
	typedef TestLLSDLegacyXMLParsingGroup::object TestLLSDLegacyXMLParsingObject;
	TestLLSDLegacyXMLParsingGroup gTestLLSDLegacyXMLParsingGroup("llsd legacy XML parsing");

	template<> template<>
	void TestLLSDLegacyXMLParsingObject::test<1>()
	{
		// test handling of legacy header form

		LLSD v = "amy";

		ensureParse("normal form",
					"<llsd><string>amy</string></llsd>",
					v);

		ensureParse("legacy form",
					"<? LLSD/XML ?>\n"
					"<llsd><string>amy</string></llsd>",
					v);

		ensureParse("normal XML declaration form",
					"<?xml version='1.0'?>\n"
					"<llsd><string>amy</string></llsd>",
					v);

		ensureParse("legacy form with XML declaration",
					"<? LLSD/XML ?>\n"
					"<?xml version='1.0'?>\n"
					"<llsd><string>amy</string></llsd>",
					v);
	}

	template<> template<>
	void TestLLSDLegacyXMLParsingObject::test<2>()
	{
		// test handling legacy boolean encoding
		LLSD vt = true;
		LLSD vf = false;

		ensureParse("legacy true",  "<llsd><boolean>1</boolean></llsd>", vt);
		ensureParse("legacy false", "<llsd><boolean>0</boolean></llsd>", vf);
		ensureParse("normal true",  "<llsd><boolean>true</boolean></llsd>", vt);
		ensureParse("normal false", "<llsd><boolean>false</boolean></llsd>", vf);
		ensureParse("empty false",  "<llsd><boolean/></llsd>", vf);
		ensureParse("garbage false", "<llsd><boolean>foobar</boolean></llsd>", vf);
	}


	template<> template<>
	void TestLLSDLegacyXMLParsingObject::test<3>()
	{
		// test handling of unrecognized or unparseable llsd values
		LLSD v;
		v["amy"] = 23;
		v["bob"] = LLSD();
		v["cam"] = 1.23;

		ensureParse(
					"unknown data type",
					"<llsd><map>"
					"<key>amy</key><integer>23</integer>"
					"<key>bob</key><bigint>99999999999999999</bigint>"
					"<key>cam</key><real>1.23</real>"
					"</map></llsd>",
					v);
	}

	template<> template<>
	void TestLLSDLegacyXMLParsingObject::test<4>()
	{
		// test handling of nested bad data

		LLSD v;
		v["amy"] = 23;
		v["cam"] = 1.23;

		ensureParse(
					"map with html",
					"<llsd><map>"
					"<key>amy</key><integer>23</integer>"
					"<html><body>ha ha</body></html>"
					"<key>cam</key><real>1.23</real>"
					"</map></llsd>",
					v);

		v.clear();
		v["amy"] = 23;
		v["cam"] = 1.23;
		ensureParse(
					"map with value for key",
					"<llsd><map>"
					"<key>amy</key><integer>23</integer>"
					"<string>ha ha</string>"
					"<key>cam</key><real>1.23</real>"
					"</map></llsd>",
					v);

		v.clear();
		v["amy"] = 23;
		v["bob"] = LLSD::emptyMap();
		v["cam"] = 1.23;
		ensureParse(
					"map with map of html",
					"<llsd><map>"
					"<key>amy</key><integer>23</integer>"
					"<key>bob</key>"
					"<map>"
					"<html><body>ha ha</body></html>"
					"</map>"
					"<key>cam</key><real>1.23</real>"
					"</map></llsd>",
					v);

		v.clear();
		v[0] = 23;
		v[1] = LLSD();
		v[2] = 1.23;

		ensureParse(
					"array value of html",
					"<llsd><array>"
					"<integer>23</integer>"
					"<html><body>ha ha</body></html>"
					"<real>1.23</real>"
					"</array></llsd>",
					v);

		v.clear();
		v[0] = 23;
		v[1] = LLSD::emptyMap();
		v[2] = 1.23;
		ensureParse(
					"array with map of html",
					"<llsd><array>"
					"<integer>23</integer>"
					"<map>"
					"<html><body>ha ha</body></html>"
					"</map>"
					"<real>1.23</real>"
					"</array></llsd>",
					v);
	}
#endif // LL_LEGACY

	/**
	 * @class TestLLSDJSONParsing
	 * @brief Concrete instance of a parse tester.
	 */
	class TestLLSDJSONParsing : public TestLLSDParsing<LLSDJSONTraits>
	{
	public:
		TestLLSDJSONParsing() {}
	};

	typedef tut::test_group<TestLLSDJSONParsing> TestLLSDJSONParsingGroup;
	typedef TestLLSDJSONParsingGroup::object TestLLSDJSONParsingObject;
	TestLLSDJSONParsingGroup gTestLLSDJSONParsingGroup(
		"llsd JSON parsing");

	template<> template<>
	void TestLLSDJSONParsingObject::test<1>()
	{
		// test handling of xml not recognized as llsd results in an
		// LLSD Undefined
		ensureParseFailure("malformed map", "{\"ha ha\"", "expected :");
		ensureParseFailure("malformed array", "[\"ha ha\"", "expected ]");
		ensureParseFailure("malformed string", "\"ha ha", "string");
		ensureParseFailure("bad JSON noise", "g48ejlnfr", "value");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<2>()
	{
		ensureParse("valid undef", "null", LLSD());
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<3>()
	{
		LLSD val = false;
		ensureParse("valid boolean false", "false", val);
		val = true;
		ensureParse("valid boolean true", "true", val);

		ensureParseFailure("invalid true", "TRUE", "value");
		ensureParseFailure("invalid true", "True", "value");
		ensureParseFailure("invalid true", "T", "value");
		ensureParseFailure("invalid true", "t", "value");
		ensureParseFailure("invalid false", "FALSE", "value");
		ensureParseFailure("invalid false", "False", "value");
		ensureParseFailure("invalid false", "F", "value");
		ensureParseFailure("invalid false", "f", "value");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<4>()
	{
		LLSD val = 123;
		ensureParse("valid integer", "123", val);
		ensureParseFailure("invalid integer", "4a21", "unrecognized");
		ensureParseFailure("invalid integer", "0123", "unrecognized");
		ensureParseFailure("invalid integer", "-", "digit");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<5>()
	{
		LLSD val = 456.7;
		ensureParse("valid real", "456.7", val);
		ensureParseFailure("invalid real", "45a6.7", "unrecognized");
		ensureParseFailure("invalid real", ".123", "value");
		ensureParseFailure("invalid real", "012.34", "unrecognized");
		ensureParseFailure("invalid real", "-", "digit");
		ensureParseFailure("invalid real", "-x", "digit");
		ensureParseFailure("invalid real", "1.", "digit");
		ensureParseFailure("invalid real", "1.x", "digit");
		ensureParseFailure("invalid real", "1.2e", "digit");
		ensureParseFailure("invalid real", "1.2ex", "digit");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<6>()
	{
		ensureParseFailure("unparseable uuid", "u123", "value");

		LLSD::UUID id("2ba66d4e-feba-4303-9047-7dc006f046dc");
		std::ostringstream uuid_str;
		uuid_str << '"' << id.asString() << '"';

		// in JSON, UUID is just a string, so this is not much of a test
		ensureParse("valid uuid", uuid_str.str(), id.asString());
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<7>()
	{
		LLSD val = std::string("foolish");
		ensureParse("valid string 1", "\"foolish\"", val);
		val = std::string("g'day");
		ensureParse("valid string 2", "\"g'day\"", val);
		val = std::string("have a \"nice\" day");
		ensureParse("valid string 3", "\"have a \\\"nice\\\" day\"", val);
		val = std::string("whatever");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<8>()
	{
		ensureParseFailure("invalid string 1", "\"whatever", "string");
		ensureParseFailure("invalid string 2", "whatever\\\"", "value");
		ensureParseFailure("invalid string 3", "'whatever'", "value");
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<9>()
	{
		LLSD val = LLSD::URI("http://www.example.com");

		// in JSON, URI is just a string, so this is not much of a test
		ensureParse("valid uri", "\"http://www.example.com\"", val.asString());
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<10>()
	{
		LLSD val = LLSD::Date("2007-12-28T09:22:53.10Z");
		// in JSON, Date is just a string, so this is not much of a test
		ensureParse("valid date", "\"2007-12-28T09:22:53.100Z\"", val.asString());
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<11>()
	{
		// in JSON, Binary is just a base64 string, so this is not much of a test
		//std::vector<U8> vec;
		//vec.push_back((U8)'a'); vec.push_back((U8)'b'); vec.push_back((U8)'c');
		//vec.push_back((U8)'3'); vec.push_back((U8)'2'); vec.push_back((U8)'1');
		//LLSD val = vec;
		//ensureParse("valid binary b64", "\"YWJjMzIx\"", val);
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<13>()
	{
		LLSD val;
		val["amy"] = 23;
		val["bob"] = LLSD();
		val["cam"] = 1.23;
		ensureParse("simple map", "{\"amy\":23,\"bob\":null,\"cam\":1.23}", val);

		val["bob"] = LLSD::emptyMap();
		val["bob"]["vehicle"] = std::string("bicycle");
		ensureParse(
			"nested map",
			"{\"amy\":23,\"bob\":{\"vehicle\":\"bicycle\"},\"cam\":1.23}",
			val);
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<14>()
	{
		LLSD val;
		val.append(23);
		val.append(LLSD());
		val.append(1.23);
		ensureParse("simple array", "[23,null,1.23]", val);
		val[1] = LLSD::emptyArray();
		val[1].append("bicycle");
		ensureParse("nested array", "[23,[\"bicycle\"],1.23]", val);
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<15>()
	{
		LLSD val;
		val["amy"] = 23;
		val["bob"]["dogs"] = LLSD::emptyArray();
		val["bob"]["dogs"].append(LLSD::emptyMap());
		val["bob"]["dogs"][0]["name"] = std::string("groove");
		val["bob"]["dogs"][0]["breed"] = std::string("samoyed");
		val["bob"]["dogs"].append(LLSD::emptyMap());
		val["bob"]["dogs"][1]["name"] = std::string("greyley");
		val["bob"]["dogs"][1]["breed"] = std::string("chow/husky");
		val["cam"] = 1.23;
		ensureParse(
			"nested",
			"{\"amy\":23,"
			" \"bob\":{\"dogs\":["
			         "{\"name\":\"groove\", \"breed\":\"samoyed\"},"
			         "{\"name\":\"greyley\", \"breed\":\"chow/husky\"}]},"
			" \"cam\":1.23}",
			val);
	}

	template<> template<>
	void TestLLSDJSONParsingObject::test<16>()
	{
		ensureParseFailure("invalid escape sequence", "\"abc\\q123\"", "escape");
		ensureParseFailure("truncated escape sequence", "\"abc\\u\"", "escape");
		ensureParseFailure("truncated escape sequence", "\"abc\\u1\"", "escape");
		ensureParseFailure("truncated escape sequence", "\"abc\\u12\"", "escape");
		ensureParseFailure("truncated escape sequence", "\"abc\\u123\"", "escape");
	}



#ifdef LL_LEGACY
	/**
	 * @class TestLLSDNotationParsing
	 * @brief Concrete instance of a parse tester.
	 */
	class TestLLSDNotationParsing : public TestLLSDParsing<LLSDNotationTraits>
	{
	public:
		TestLLSDNotationParsing() {}
	};

	typedef tut::test_group<TestLLSDNotationParsing> TestLLSDNotationParsingGroup;
	typedef TestLLSDNotationParsingGroup::object TestLLSDNotationParsingObject;
	TestLLSDNotationParsingGroup gTestLLSDNotationParsingGroup(
		"llsd notation parsing");

	template<> template<>
	void TestLLSDNotationParsingObject::test<1>()
	{
		// test handling of xml not recognized as llsd results in an
		// LLSD Undefined
		ensureParseFailure("malformed map", "{'ha ha'", "map");
		ensureParseFailure("malformed array", "['ha ha'", "array");
		ensureParseFailure("malformed string", "'ha ha", "string");
		ensureParseFailure("bad notation noise", "g48ejlnfr", "unrecognized");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<2>()
	{
		ensureParse("valid undef", "!", LLSD());
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<3>()
	{
		LLSD val = false;
		ensureParse("valid boolean false 0", "false", val);
		ensureParse("valid boolean false 1", "f", val);
		ensureParse("valid boolean false 2", "0", val);
		ensureParse("valid boolean false 3", "F", val);
		ensureParse("valid boolean false 4", "FALSE", val);
		val = true;
		ensureParse("valid boolean true 0", "true", val);
		ensureParse("valid boolean true 1", "t", val);
		ensureParse("valid boolean true 2", "1", val);
		ensureParse("valid boolean true 3", "T", val);
		ensureParse("valid boolean true 4", "TRUE", val);

		ensureParseFailure("invalid true", "TR", "boolean");
		ensureParseFailure("invalid false", "FAL", "boolean");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<4>()
	{
		LLSD val = 123;
		ensureParse("valid integer", "i123", val);
		ensureParseFailure("invalid integer", "421", "unrecognized");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<5>()
	{
		LLSD val = 456.7;
		ensureParse("valid real", "r456.7", val);
		ensureParseFailure("invalid real", "456.7", "unrecognized");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<6>()
	{
		LLSD::UUID id("2ba66d4e-feba-4303-9047-7dc006f046dc");
		LLSD val = id;
		ensureParseFailure("unparseable uuid", "u123", "uuid");
		val = id;
		std::string uuid_str("u");
		uuid_str += id.asString();
		ensureParse("valid uuid", uuid_str.c_str(), val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<7>()
	{
		LLSD val = std::string("foolish");
		ensureParse("valid string 1", "\"foolish\"", val);
		val = std::string("g'day");
		ensureParse("valid string 2", "\"g'day\"", val);
		val = std::string("have a \"nice\" day");
		ensureParse("valid string 3", "'have a \"nice\" day'", val);
		val = std::string("whatever");
		ensureParse("valid string 4", "s(8)\"whatever\"", val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<8>()
	{
		ensureParseFailure("invalid string 1", "s(7)\"whatever\"", "string");
		ensureParseFailure("invalid string 2", "s(9)\"whatever\"", "string");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<9>()
	{
		LLSD val = LLSD::URI("http://www.google.com");
		ensureParse("valid uri", "l\"http://www.google.com\"", val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<10>()
	{
		LLSD val = LLSD::Date("2007-12-28T09:22:53.10Z");
		ensureParse("valid date", "d\"2007-12-28T09:22:53.10Z\"", val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<11>()
	{
		std::vector<U8> vec;
		vec.push_back((U8)'a'); vec.push_back((U8)'b'); vec.push_back((U8)'c');
		vec.push_back((U8)'3'); vec.push_back((U8)'2'); vec.push_back((U8)'1');
		LLSD val = vec;
		ensureParse("valid binary b64", "b64\"YWJjMzIx\"", val);
		ensureParse("valid bainry b16", "b16\"616263333231\"", val);
		ensureParse("valid bainry raw", "b(6)\"abc321\"", val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<12>()
	{
		ensureParseFailure(
			"invalid -- binary length specified too long",
			"b(7)\"abc321\"",
			"binary");
		ensureParseFailure(
			"invalid -- binary length specified way too long",
			"b(1000000)\"abc321\"",
			"binary");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<13>()
	{
		LLSD val;
		val["amy"] = 23;
		val["bob"] = LLSD();
		val["cam"] = 1.23;
		ensureParse("simple map", "{'amy':i23,'bob':!,'cam':r1.23}", val);

		val["bob"] = LLSD::emptyMap();
		val["bob"]["vehicle"] = std::string("bicycle");
		ensureParse(
			"nested map",
			"{'amy':i23,'bob':{'vehicle':'bicycle'},'cam':r1.23}",
			val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<14>()
	{
		LLSD val;
		val.append(23);
		val.append(LLSD());
		val.append(1.23);
		ensureParse("simple array", "[i23,!,r1.23]", val);
		val[1] = LLSD::emptyArray();
		val[1].append("bicycle");
		ensureParse("nested array", "[i23,['bicycle'],r1.23]", val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<15>()
	{
		LLSD val;
		val["amy"] = 23;
		val["bob"]["dogs"] = LLSD::emptyArray();
		val["bob"]["dogs"].append(LLSD::emptyMap());
		val["bob"]["dogs"][0]["name"] = std::string("groove");
		val["bob"]["dogs"][0]["breed"] = std::string("samoyed");
		val["bob"]["dogs"].append(LLSD::emptyMap());
		val["bob"]["dogs"][1]["name"] = std::string("greyley");
		val["bob"]["dogs"][1]["breed"] = std::string("chow/husky");
		val["cam"] = 1.23;
		ensureParse(
			"nested notation",
			"{'amy':i23,"
			" 'bob':{'dogs':["
			         "{'name':'groove', 'breed':'samoyed'},"
			         "{'name':'greyley', 'breed':'chow/husky'}]},"
			" 'cam':r1.23}",
			val);
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<16>()
	{
		// text to make sure that incorrect sizes bail because
		std::string bad_str("s(5)\"hi\"");
		ensureParseFailure(
			"size longer than bytes left",
			bad_str,
			"string");
	}

	template<> template<>
	void TestLLSDNotationParsingObject::test<17>()
	{
		// text to make sure that incorrect sizes bail because
		std::string bad_bin("b(5)\"hi\"");
		ensureParseFailure(
			"size longer than bytes left",
			bad_bin,
			"binary");
	}
#endif // LL_LEGACY

	/**
	 * @class TestLLSDBinaryParsing
	 * @brief Concrete instance of a parse tester.
	 */
	class TestLLSDBinaryParsing : public TestLLSDParsing<LLSDBinaryTraits>
	{
	public:
		TestLLSDBinaryParsing() {}
	};

	typedef tut::test_group<TestLLSDBinaryParsing> TestLLSDBinaryParsingGroup;
	typedef TestLLSDBinaryParsingGroup::object TestLLSDBinaryParsingObject;
	TestLLSDBinaryParsingGroup gTestLLSDBinaryParsingGroup(
		"llsd binary parsing");

	template<> template<>
	void TestLLSDBinaryParsingObject::test<1>()
	{
		std::vector<U8> vec;
		vec.resize(6);
		vec[0] = 'a'; vec[1] = 'b'; vec[2] = 'c';
		vec[3] = '3'; vec[4] = '2'; vec[5] = '1';
		std::string string_expected((char*)&vec[0], vec.size());
		LLSD value = string_expected;

		vec.resize(11);
		vec[0] = 's'; // for string
		vec[5] = 'a'; vec[6] = 'b'; vec[7] = 'c';
		vec[8] = '3'; vec[9] = '2'; vec[10] = '1';

		uint32_t size = htonl(6);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_good((char*)&vec[0], vec.size());
		ensureParse("correct string", str_good, value);

		size = htonl(7);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_1((char*)&vec[0], vec.size());
		ensureParseFailure("incorrect size string 1", str_bad_1, "string");

		size = htonl(100000);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_2((char*)&vec[0], vec.size());
		ensureParseFailure("incorrect size string 2", str_bad_2, "string");
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<2>()
	{
		std::vector<U8> vec;
		vec.resize(6);
		vec[0] = 'a'; vec[1] = 'b'; vec[2] = 'c';
		vec[3] = '3'; vec[4] = '2'; vec[5] = '1';
		LLSD value = vec;

		vec.resize(11);
		vec[0] = 'b';  // for binary
		vec[5] = 'a'; vec[6] = 'b'; vec[7] = 'c';
		vec[8] = '3'; vec[9] = '2'; vec[10] = '1';

		uint32_t size = htonl(6);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_good((char*)&vec[0], vec.size());
		ensureParse("correct binary", str_good, value);

		size = htonl(7);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_1((char*)&vec[0], vec.size());
		ensureParseFailure("incorrect size binary 1", str_bad_1, "binary");

		size = htonl(100000);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_2((char*)&vec[0], vec.size());
		ensureParseFailure("incorrect size binary 2", str_bad_2, "binary");
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<3>()
	{
		ensureParseFailure("malformed map", "{'ha ha'", "unrecognized");
		ensureParseFailure("malformed array", "['ha ha'", "unrecognized");
#ifdef LL_LEGACY
		ensureParseFailure("legacy string", "'ha ha", "legacy");
#else
		ensureParseFailure("legacy string", "'ha ha", "unrecognized");
#endif
		ensureParseFailure("bad noise", "g48ejlnfr", "unrecognized");
	}
	template<> template<>
	void TestLLSDBinaryParsingObject::test<4>()
	{
		ensureParse("valid undef", "!", LLSD());
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<5>()
	{
		LLSD val = false;
		ensureParse("valid boolean false 2", "0", val);
		val = true;
		ensureParse("valid boolean true 2", "1", val);

		val.clear();
		ensureParseFailure("invalid true", "t", "unrecognized");
		ensureParseFailure("invalid false", "f", "unrecognized");
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<6>()
	{
		std::vector<U8> vec;
		vec.push_back('{');
		vec.resize(vec.size() + 4);
		uint32_t size = htonl(1);
		memcpy(&vec[1], &size, sizeof(uint32_t));
		vec.push_back('k');
		int key_size_loc = vec.size();
		size = htonl(1); // 1 too short
		vec.resize(vec.size() + 4);
		memcpy(&vec[key_size_loc], &size, sizeof(uint32_t));
		vec.push_back('a'); vec.push_back('m'); vec.push_back('y');
		vec.push_back('i');
		int integer_loc = vec.size();
		vec.resize(vec.size() + 4);
		uint32_t val_int = htonl(23);
		memcpy(&vec[integer_loc], &val_int, sizeof(uint32_t));
		std::string str_bad_1((char*)&vec[0], vec.size());
		ensureParseFailure(
			"invalid key size",
			str_bad_1);
			// once parsing is off, almost anything can be the cause of the
			// error, so no explicit check for error message here

		// check with correct size, but unterminated map (missing '}')
		size = htonl(3); // correct size
		memcpy(&vec[key_size_loc], &size, sizeof(uint32_t));
		std::string str_bad_2((char*)&vec[0], vec.size());
		ensureParseFailure(
			"valid key size, unterminated map",
			str_bad_2,
			"map");

		// check w/ correct size and correct map termination
		LLSD val;
		val["amy"] = 23;
		vec.push_back('}');
		std::string str_good((char*)&vec[0], vec.size());
		ensureParse(
			"valid map",
			str_good,
			val);

		// check w/ incorrect sizes and correct map termination
		size = htonl(0); // 1 too few (for the map entry)
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_3((char*)&vec[0], vec.size());
		ensureParseFailure(
			"invalid map too long",
			str_bad_3,
			"map");

		size = htonl(2); // 1 too many
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_4((char*)&vec[0], vec.size());
		ensureParseFailure(
			"invalid map too short",
			str_bad_4,
			"map");
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<7>()
	{
		std::vector<U8> vec;
		vec.push_back('[');
		vec.resize(vec.size() + 4);
		uint32_t size = htonl(1); // 1 too short
		memcpy(&vec[1], &size, sizeof(uint32_t));
		vec.push_back('s');
		int string_loc = vec.size();
		vec.resize(vec.size() + 4);
		uint32_t string_size = htonl(3);
		memcpy(&vec[string_loc], &string_size, sizeof(uint32_t));
		vec.push_back('a'); vec.push_back('m'); vec.push_back('y');
		vec.push_back('i');
		int integer_loc = vec.size();
		vec.resize(vec.size() + 4);
		uint32_t val_int = htonl(23);
		memcpy(&vec[integer_loc], &val_int, sizeof(uint32_t));

		std::string str_bad_1((char*)&vec[0], vec.size());
		ensureParseFailure(
			"invalid array size",
			str_bad_1,
		    "array");

		// check with correct size, but unterminated map (missing ']')
		size = htonl(2); // correct size
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_2((char*)&vec[0], vec.size());
		ensureParseFailure(
			"unterminated array",
			str_bad_2,
		    "array");

		// check w/ correct size and correct map termination
		LLSD val;
		val.append("amy");
		val.append(23);
		vec.push_back(']');
		std::string str_good((char*)&vec[0], vec.size());
		ensureParse(
			"valid array",
			str_good,
			val);

		// check with too many elements
		size = htonl(3); // 1 too long
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_bad_3((char*)&vec[0], vec.size());
		ensureParseFailure(
			"array too short",
			str_bad_3,
		    "array");
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<8>()
	{
		std::vector<U8> vec;
		vec.push_back('{');
		vec.resize(vec.size() + 4);
		memset(&vec[1], 0, 4);
		vec.push_back('}');
		std::string str_good((char*)&vec[0], vec.size());
		LLSD val = LLSD::emptyMap();
		ensureParse(
			"empty map",
			str_good,
			val);
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<9>()
	{
		std::vector<U8> vec;
		vec.push_back('[');
		vec.resize(vec.size() + 4);
		memset(&vec[1], 0, 4);
		vec.push_back(']');
		std::string str_good((char*)&vec[0], vec.size());
		LLSD val = LLSD::emptyArray();
		ensureParse(
			"empty array",
			str_good,
			val);
	}

	template<> template<>
	void TestLLSDBinaryParsingObject::test<10>()
	{
		std::vector<U8> vec;
		vec.push_back('l');
		vec.resize(vec.size() + 4);
		uint32_t size = htonl(14); // 1 too long
		memcpy(&vec[1], &size, sizeof(uint32_t));
		vec.push_back('h'); vec.push_back('t'); vec.push_back('t');
		vec.push_back('p'); vec.push_back(':'); vec.push_back('/');
		vec.push_back('/'); vec.push_back('s'); vec.push_back('l');
		vec.push_back('.'); vec.push_back('c'); vec.push_back('o');
		vec.push_back('m');
		std::string str_bad((char*)&vec[0], vec.size());
		ensureParseFailure(
			"invalid uri length size",
			str_bad,
			"uri");

		LLSD val;
		val = LLSD::URI("http://sl.com");
		size = htonl(13); // correct length
		memcpy(&vec[1], &size, sizeof(uint32_t));
		std::string str_good((char*)&vec[0], vec.size());
		ensureParse(
			"valid key size",
			str_good,
			val);
	}

#ifdef LL_LEGACY
	class TestLLSDLegacyBinaryParsing : public TestLLSDParsing<LLSDLegacyBinaryTraits>
	{
	public:
		TestLLSDLegacyBinaryParsing() {}
	};

	typedef tut::test_group<TestLLSDLegacyBinaryParsing> TestLLSDLegacyBinaryParsingGroup;
	typedef TestLLSDLegacyBinaryParsingGroup::object TestLLSDLegacyBinaryParsingObject;
	TestLLSDLegacyBinaryParsingGroup gTestLLSDLegacyBinaryParsingGroup(
														   "llsd legacy binary parsing");

	template<> template<>
	void TestLLSDLegacyBinaryParsingObject::test<1>()
	{
		std::string normal = "1";
		std::string legacy1 = "<? LLSD/Binary ?>\n1"; // from old LLSDSerialize::seriailze()
		std::string legacy2 = "<?LLSD/Binary?>\n1";	  // from Python llbase

		LLSD val = true;
		ensureParse("normal format",		normal, val);
		ensureParse("legacy format",		legacy1, val);
		ensureParse("python legacy format", legacy2, val);
	}

	template<> template<>
	void TestLLSDLegacyBinaryParsingObject::test<2>()
	{
		std::vector<U8> vec;
		vec.push_back('"'); vec.push_back('a'); vec.push_back('m');
		vec.push_back('y'); vec.push_back('"');

		LLSD val;
		val = "amy";

		std::string str((char*)&vec[0], vec.size());
		ensureParse("legacy string encoding", str, val);
	}
#endif // LL_LEGACY


   /**
	 * @class TestLLSDCrossCompatible
	 * @brief Miscellaneous serialization and parsing tests
	 */
	class TestLLSDCrossCompatible
	{
	public:
		TestLLSDCrossCompatible() {}

		void ensureCompatible(
			const std::string& msg,
			const LLSD& input)
		{
			// to binary, and back again
			std::stringstream str1;
			LLSD actual_value_bin;
			str1 << LLSDToBinary(input);
			str1 >> LLSDFromBinary(actual_value_bin);

			// to xml and back again
			std::stringstream str2;
			LLSD actual_value_xml;
			str2 << LLSDToXML(actual_value_bin);
			str2 >> LLSDFromXML(actual_value_xml);

			ensure_equals(
						  msg + " (binary and xml)",
						  actual_value_xml,
						  input);

#ifdef LL_LEGACY
			// to notation and back again
			std::stringstream str3;
			LLSD actual_value_notation;
			str3 << LLSDToNotation(actual_value_bin);
			str3 >> LLSDFromNotation(actual_value_notation);

			ensure_equals(
				msg + " (binary and notation)",
				actual_value_notation,
				input);
#endif
		}
	};

	typedef tut::test_group<TestLLSDCrossCompatible> TestLLSDCompatibleGroup;
	typedef TestLLSDCompatibleGroup::object TestLLSDCompatibleObject;
	TestLLSDCompatibleGroup gTestLLSDCompatibleGroup(
		"llsd serialize compatible");

	template<> template<>
	void TestLLSDCompatibleObject::test<1>()
	{
		LLSD test;
		ensureCompatible("undef", test);
		test = true;
		ensureCompatible("boolean true", test);
		test = false;
		ensureCompatible("boolean false", test);
		test = 0;
		ensureCompatible("integer zero", test);
		test = 1;
		ensureCompatible("integer positive", test);
		test = -234567;
		ensureCompatible("integer negative", test);
		test = 0.0;
		ensureCompatible("real zero", test);
		test = 1.0;
		ensureCompatible("real positive", test);
		test = -1.0;
		ensureCompatible("real negative", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<2>()
	{
		LLSD test;
		test = "foobar";
		ensureCompatible("string", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<3>()
	{
		LLSD test;
		LLSD::UUID id("5f39ae8d-d3c5-459a-8f47-4767a4a4799d");
		test = id;
		ensureCompatible("uuid", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<4>()
	{
		LLSD test;
		test = LLSD::Date(12345.0);
		ensureCompatible("date", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<5>()
	{
		LLSD test;
		test = LLSD::URI("http://www.secondlife.com/");
		ensureCompatible("uri", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<6>()
	{
		LLSD test;
		typedef std::vector<U8> buf_t;
		buf_t val;
		for(int ii = 0; ii < 100; ++ii)
		{
			srand(ii);		/* Flawfinder: ignore */
			S32 size = rand() % 100 + 10;
			std::generate_n(
				std::back_insert_iterator<buf_t>(val),
				size,
				rand);
		}
		test = val;
		ensureCompatible("binary", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<7>()
	{
		LLSD test;
		test = LLSD::emptyArray();
		test.append(1);
		test.append("hello");
		ensureCompatible("array", test);
	}

	template<> template<>
	void TestLLSDCompatibleObject::test<8>()
	{
		LLSD test;
		test = LLSD::emptyArray();
		test["foo"] = "bar";
		test["baz"] = 100;
		ensureCompatible("map", test);
	}
}

